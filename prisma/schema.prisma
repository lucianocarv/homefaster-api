datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
  binaryTargets   = ["native", "debian-openssl-3.0.x", "linux-musl-openssl-3.0.x", "debian-openssl-1.1.x"]
}

generator zod {
  provider              = "zod-prisma"
  output                = "./models" // (default) the directory where generated zod schemas will be saved
  relationModel         = true // (default) Create and export both plain and related models.
  modelCase             = "PascalCase" // (default) Output models using pascal case (ex. UserModel, PostModel)
  modelSuffix           = "Model" // (default) Suffix to apply to your prisma models when naming Zod schemas
  useDecimalJs          = true // represent the prisma Decimal type using Decimal.js (as Prisma does)
  prismaJsonNullability = true // (default) uses prisma's scheme for JSON field nullability
}

model Province {
  id         Int      @id @default(autoincrement())
  /// @zod.max(32, {message: "O nome da província não pode ter mais de 32 caracteres!"})
  /// @zod.min(3, {message: "O nome da província deve ter pelo menos 3 caracteres!"})
  name       String   @unique @db.VarChar(32)
  /// @zod.length(2, {message: "A abreviação deve ter apenas 2 caracteres!"}).toUpperCase()
  short_name String   @unique @db.VarChar(2)
  /// @zod.url({message: "A imagem de fundo precisa referenciar um endereço url!"})
  img_cover  String?  @db.VarChar(255)
  cities     City[]
  created_at DateTime @default(now()) @db.Timestamp()
  updated_at DateTime @updatedAt @db.Timestamp()

  @@map("provinces")
}

model City {
  id          Int         @id @default(autoincrement())
  /// @zod.max(32, {message: "O nome da cidade não pode ter mais de 32 caracteres!"})
  /// @zod.min(3, {message: "O nome da cidade deve ter pelo menos 3 caracteres!"})
  name        String      @db.VarChar(32)
  latitude    Float
  longitude   Float
  place_id    String      @unique @db.VarChar(255)
  /// @zod.url({message: "A imagem de fundo precisa referenciar um endereço url!"})
  img_cover   String?     @db.VarChar(255)
  province    Province    @relation(fields: [province_id], references: [id], onUpdate: Cascade)
  province_id Int
  communities Community[]
  properties  Property[]
  created_at  DateTime    @default(now()) @db.Timestamp()
  updated_at  DateTime    @updatedAt @db.Timestamp()

  @@unique([province_id, place_id])
  @@map("cities")
}

model Community {
  id                Int        @id @default(autoincrement())
  /// @zod.max(32, {message: "O nome da comunidade não pode ter mais de 32 caracteres!"})
  /// @zod.min(3, {message: "O nome da comunidade deve ter pelo menos 3 caracteres!"})
  name              String     @db.VarChar(32)
  global_code       String     @unique @db.VarChar(255)
  formatted_address String     @db.VarChar(255)
  latitude          Float
  longitude         Float
  /// @zod.url({message: "A imagem de fundo precisa referenciar um endereço url!"})
  img_cover         String?    @db.VarChar(255)
  city              City       @relation(fields: [city_id], references: [id], onUpdate: Cascade)
  city_id           Int
  properties        Property[]
  created_at        DateTime   @default(now()) @db.Timestamp()
  updated_at        DateTime   @updatedAt @db.Timestamp()

  @@unique([name, city_id])
  @@map("communities")
}

model Property {
  id           Int          @id @default(autoincrement())
  community    Community    @relation(fields: [community_id], references: [id], onUpdate: Cascade)
  community_id Int
  description  Description?
  address      Address?
  city         City         @relation(fields: [city_id], references: [id], onUpdate: Cascade)
  city_id      Int
  favorites    Favorite[]
  created_at   DateTime     @default(now()) @db.Timestamp()
  updated_at   DateTime     @updatedAt @db.Timestamp()
  listed_by    User         @relation(fields: [user_id], references: [id], onUpdate: Cascade)
  user_id      Int

  @@map("properties")
}

model Address {
  id                Int      @id @default(autoincrement())
  /// @zod.positive({message: "O número da propriedade precisar ser positivo!"})
  number            Int
  street            String   @db.VarChar(255)
  /// @zod.max(16)
  postal_code       String?  @db.VarChar(16)
  global_code       String   @unique @db.VarChar(255)
  place_id          String   @unique @db.VarChar(255)
  formatted_address String
  latitude          Float
  longitude         Float
  community         String   @db.VarChar(255)
  city              String   @db.VarChar(255)
  province          String   @db.VarChar(255)
  property          Property @relation(fields: [property_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  property_id       Int      @unique
  created_at        DateTime @default(now()) @db.Timestamp()
  updated_at        DateTime @updatedAt @db.Timestamp()

  @@unique([id, property_id])
  @@map("p_addresses")
}

model Description {
  id            Int                       @id @default(autoincrement())
  title         String                    @db.VarChar(255)
  img_cover     String?                   @db.VarChar(255)
  /// @zod.positive({message: "O valor do aluguel precisa ser positivo!"})
  price         Float                     @db.Real
  /// @zod.min(1, {message:"A quantidade de banheiros precisar ser igual ou maior que 1"})
  bathrooms     Int
  /// @zod.min(1, {message:"A quantidade de quartos precisar ser igual ou maior que 1"})
  badrooms      Int
  furnished     Boolean
  rented        Boolean                   @default(false)
  /// @zod.min(1, {message:"A área da propriedade precisar ser igual ou maior que 1"})
  property_area Float                     @db.Real
  pets_cats     Int
  pets_dogs     Int
  smoking       Boolean
  type          Type                      @relation(fields: [type_id], references: [id])
  type_id       Int
  utilities     UtilitiesOnDescriptions[]
  features      FeaturesOnDescriptions[]
  created_at    DateTime                  @default(now()) @db.Timestamp()
  updated_at    DateTime                  @updatedAt @db.Timestamp()
  property      Property                  @relation(fields: [property_id], references: [id], onUpdate: Cascade, onDelete: Cascade)
  property_id   Int                       @unique

  @@unique([id, property_id])
  @@map("p_descriptions")
}

model Utility {
  id                        Int                       @id @default(autoincrement())
  /// @zod.min(3, {message:"O nome da utilidade precisar ter pelo menos 3 caracteres!"})
  name                      String                    @unique @db.VarChar(255)
  utilities_on_descriptions UtilitiesOnDescriptions[]
  created_at                DateTime                  @default(now()) @db.Timestamp()
  updated_at                DateTime                  @updatedAt @db.Timestamp()

  @@map("p_utilities")
}

model UtilitiesOnDescriptions {
  description    Description @relation(fields: [description_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  description_id Int
  utility        Utility     @relation(fields: [utility_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  utility_id     Int
  created_at     DateTime    @default(now()) @db.Timestamp()
  updated_at     DateTime    @updatedAt @db.Timestamp()

  @@unique([description_id, utility_id])
  @@map("utilities_on_descriptions")
}

enum FeatureType {
  Property
  Building
  Community
}

model Feature {
  id                       Int                      @id @default(autoincrement())
  /// @zod.min(2, {message: "O nome da feature precisa ter pelo menos 2 caracteres!"})
  name                     String                   @db.VarChar(255)
  type                     FeatureType
  features_on_descriptions FeaturesOnDescriptions[]
  created_at               DateTime                 @default(now()) @db.Timestamp()
  updated_at               DateTime                 @updatedAt @db.Timestamp()

  @@unique([name])
  @@map("p_features")
}

model FeaturesOnDescriptions {
  description    Description @relation(fields: [description_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  description_id Int
  feature        Feature     @relation(fields: [feature_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  feature_id     Int
  created_at     DateTime    @default(now()) @db.Timestamp()
  updated_at     DateTime    @updatedAt @db.Timestamp()

  @@id([description_id, feature_id])
  @@map("features_on_descriptions")
}

model Type {
  id          Int           @id @default(autoincrement())
  /// @zod.min(2, {message:"O nome do tipo de propriedade precisar ter no mínimo 2 caracteres!"})
  name        String        @unique @db.VarChar(255)
  Description Description[]
  created_at  DateTime      @default(now()) @db.Timestamp()
  updated_at  DateTime      @updatedAt @db.Timestamp()

  @@map("p_types")
}

enum Role {
  User
  Admin
}

model User {
  id                Int        @id @default(autoincrement())
  /// @zod.min(2, {message: "O nome precisar ter 2 ou mais caracteres!"})
  first_name        String     @db.VarChar(255)
  /// @zod.min(2, {message: "O sobrenome precisa ter 2 ou mais caracteres!"})
  last_name         String     @db.VarChar(255)
  /// @zod.email({message: "O email precisa ser do tipo email@email.com"})
  email             String     @unique
  password          String
  phone             String?
  role              Role
  account_confirmed Boolean    @default(false)
  favorites         Favorite[]
  properties        Property[]

  @@map("users")
}

model Favorite {
  id          Int      @id @default(autoincrement())
  user        User     @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user_id     Int
  property    Property @relation(fields: [property_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  property_id Int

  @@unique([user_id, property_id])
  @@map("u_favorites")
}
